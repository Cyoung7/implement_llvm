# llvm简介

[原文链接](http://www.aosabook.org/en/llvm.html)

[TOC]

本章讨论了一些在LLVM成型的设计决策，这是一个包含和开发一组紧密结合的低级工具链组件（例如，汇编器，编译器，调试器等）的伞状项目，它被设计成需要在类Unix系统上兼容已存在的工具。 “LLVM”这个名字曾经是一个缩写词，但现在只是伞形项目的一个品牌。 虽然LLVM提供了一些独特的功能，并且以其一些出色的工具而闻名（例如，Clang编译器 ，C / C ++ / Objective-C编译器，它提供了许多优于GCC编译器的优点），但是LLVM与其他编译器不同的主要是它的内部架构。

从2000年12月开始，LLVM被设计为一组具有良好定义接口的可重用库。 当时，开源编程语言实现被设计为通常具有单独可执行文件的专用工具。 例如，从静态编译器（例如，GCC）重用解析器进行静态分析或重构是非常困难的。 虽然脚本语言通常提供了将运行时和解释器嵌入到更大的应用程序中的方法，但是这个运行时是一个单个整体代码块,他可能被包含在内或排除在外。 没有办法重复使用片段，并且很少在语言实现项目中共享。

除了编译器本身的组成之外，流行语言实现的社区通常是强烈的两极化：一个实现通常提供传统的静态编译器，如GCC，Free Pascal和FreeBASIC， 或者它提供了一个解释器形式的运行时编译器或即时（JIT）编译器。 看到支持两者的语言实现非常罕见，即使他们这样做，通常也很少实现代码共享。

在过去的十年中，LLVM已经彻底改变了这种状况。 LLVM现在被用作实现各种静态和运行时编译语言的通用基础结构（例如，由GCC，Java，.NET，Python，Ruby，Scheme，Haskell，D支持的语言系列，以及无数的较小的语言已知语言）。 它还取代了各种各样的专用编译器，例如Apple的OpenGL堆栈中的运行时专用引擎和Adobe After Effects产品中的图像处理库。 最后，LLVM还被用于创建各种各样的新产品，其中最着名的可能是OpenCL GPU编程语言和运行时。

## 1.经典编译器设计

传统静态编译器（如大多数C编译器）最流行的设计是三阶段设计，其主要组件是前端，优化器和后端。 前端解析源代码，检查它是否有错误，并构建一个特定于语言的抽象语法树（AST）来表示输入代码。 AST可选地转换为新的表示以进行优化，优化器和后端在代码上运行。

![SimpleCompiler](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/SimpleCompiler.png)

​								三阶段编译器的三个主要组件

优化器负责进行各种各样的转换以尝试改进代码的运行时间，例如消除冗余计算，并且通常或多或少地独立于语言和目标。 然后，后端（也称为代码生成器）将代码映射到目标指令集。 除了生成正确的代码外，它还负责生成充分利用硬件支持的体系结构的优秀代码。 编译器后端的公共部分包括指令选择，寄存器分配和指令调度。

该模型同样适用于解释器和JIT编译器。 Java虚拟机（JVM）也是此模型的一个实现，它使用Java字节码作为前端和优化器之间的接口。

### 1.1 这种设计的含义

当编译器决定支持多种源语言或目标体系结构时，这种经典设计的最重要的优势就来了。 如果编译器在其优化器中使用公共代码表示，则可以为任何可以编译到它的语言编写前端，并且可以为可以从中编译的任何目标编写后端，如下图所示:

![RetargetableCompiler](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/RetargetableCompiler.png)

使用此设计，移植编译器以支持新的源语言（例如，Algol或BASIC）只需要实现新的前端，但现有的优化器和后端可以重用。 如果这些部分没有分开，那么实现新的源语言需要从头开始，因此支持`N`目标和`M`源语言需要N * M个编译器。

三阶段设计的另一个优点（直接来自可重定向性）是编译器服务于更广泛的程序员集合，而不是仅支持一种源语言和一种目标。 对于一个开源项目，这意味着可以从中抽取更大一群潜在的社区贡献者，这自然会导致编译器的更多增强和改进。 这就是为什么服务于许多社区的开源编译器（如GCC）倾向于生成比FreePASCAL等较窄的编译器更好的优化机器代码。 专有编译器的情况并非如此，其质量与项目的预算直接相关。 例如，英特尔ICC编译器因其生成的代码质量而广为人知，即使它服务于狭隘的受众。

三阶段设计的最后一个主要优势是实现前端所需的技能与优化器和后端所需的技能不同。 将这些分开使得“前端人员”更容易增强和维护他们的编译器部分。 虽然这是一个社会问题，而不是技术问题，但它在实践中很重要，特别是对于开源项目就是为了减少程序员的障碍。

### 1.2现有语言实现

虽然三阶段设计的好处在编译器教科书中引人注目并且有充分的文档记录，但实际上它几乎从未完全实现。 查看开源语言实现（当LLVM启动时），您会发现Perl，Python，Ruby和Java的实现不共享任何代码。 此外，像格拉斯哥Haskell编译器（GHC）和FreeBASIC这样的项目可以重新定位到多个不同的CPU，但是它们的实现非常特定于它们支持的一种源语言。 还部署了各种各样的专用编译器技术来实现JIT编译器，用于图像处理，正则表达式，图形卡驱动程序以及需要CPU密集型工作的其他子域.

还有，这个模型有三个主要的成功案例，第一个是Java和.NET虚拟机。 这些系统提供JIT编译器，运行时支持和定义良好的字节码格式。 这意味着任何可以编译为字节码格式的语言（数十种语言）可以再次利用优化器和JIT以及运行时。 需要权衡的是在运行时选择方面提供的实现灵活性很小：它们都强制采用JIT编译，垃圾回收以及使用非常特定的对象模型。 当遇到编译与该模型不匹配的语言（例如C）（例如，使用LLJVM项目）时，这会导致性能欠佳。

第二个成功案例可能是最不幸的，也是最常用的重用编译器技术的方法：将输入源转换为C代码（或其他语言）并通过现有的C编译器发送。 这允许重用优化器和代码生成器，提供良好的灵活性，控制运行时，并且前端实现者很容易理解，实现和维护。 不幸的是，这样做会妨碍异常处理的有效实现，提供糟糕的调试体验，减慢编译速度，并且对于需要保证尾调用(tail call)的语言（或C不支持的其他功能）可能会出现问题。

该模型的最终成功实施是GCC 。 GCC支持许多前端和后端，并且拥有活跃且广泛的贡献者社区。 GCC作为一个C编译器有着悠久的历史，它支持多个目标，并且支持其他几种语言。 随着岁月的流逝，GCC社区正在慢慢发展清洁设计。 从GCC 4.4开始，它有一个新的优化器表示（称为“GIMPLE元组”），它比前面更接近于与前端表示分离。 此外，它的Fortran和Ada前端使用干净的AST。

虽然非常成功，但这三种方法对它们的用途有很大限制，因为它们被设计为单独的应用程序。 比如，将GCC嵌入到其他应用程序中，将GCC用作运行时/ JIT编译器，或者在不引入编译器大部分的情况下提取和重用GCC片段是不现实的。 想要使用GCC的C ++前端进行文档生成，代码索引，重构和静态分析工具的人不得不将GCC用作以XML形式发送信息的独立应用程序，或编写插件以将外部代码注入GCC流程。

GCC片段不能作为库重用的原因有很多，包括全局变量的泛滥使用，弱不变的常量，数据结构的设计不良，庞大的代码库,以及使用宏阻止代码库被编译以支持更多的前端/目标对。 然而，最难解决的问题是其早期设计和时代所固有的架构问题。 具体来说，GCC会遇到分层问题和抽象漏洞：后端遍历前端AST以生成调试信息，前端生成后端数据结构，整个编译器依赖于命令行接口设置的全局数据结构。

### 1.3  LLVM的代码中间表示 LLVM IR

有了历史背景和错误经验，让我们深入研究LLVM：其设计中最重要的一项便是LLVM中间表示（IR），它是用于表示编译器中的代码格式。 LLVM IR旨在托管您在编译器的优化器部分中找到的中级分析和转换。它的设计考虑了许多具体目标，包括支持轻量级运行时优化，跨函数/过程间优化，整个程序分析和积极的重组转换等。但最重要的是，它本身被定义为具有明确语义的第一类语言。 为了具体的展现，这是一个简单的`.ll`文件示例：

```
define i32 @add1(i32 %a, i32 %b) {
entry:
  %tmp1 = add i32 %a, %b
  ret i32 %tmp1
}

define i32 @add2(i32 %a, i32 %b) {
entry:
  %tmp1 = icmp eq i32 %a, 0
  br i1 %tmp1, label %done, label %recurse

recurse:
  %tmp2 = sub i32 %a, 1
  %tmp3 = add i32 %b, 1
  %tmp4 = call i32 @add2(i32 %tmp2, i32 %tmp3)
  ret i32 %tmp4

done:
  ret i32 %b
}
```

此LLVM IR对应于此C代码，它提供了两种不同的方法来添加整数：

```c
unsigned add1(unsigned a, unsigned b) {
  return a+b;
}

// Perhaps not the most efficient way to add two numbers.
unsigned add2(unsigned a, unsigned b) {
  if (a == 0) return b;
  return add2(a-1, b+1);
}
```

从这个例子中可以看出，LLVM IR是一种类似RISC的低级虚拟指令集。 与真正的RISC指令集一样，它支持简单指令的线性序列，如加，减，比较和分支。 这些指令采用三种地址形式，这意味着它们需要一些输入并在不同的寄存器中产生结果。 LLVM IR支持标签，通常看起来像一种奇怪的汇编语言形式.

与大多数RISC指令集不同，LLVM是强类型的简单类型系统（例如， `i32`是`32位整数`， `i32**`是指向`32位整数指针`），并且机器的一些细节被抽象掉。 例如，调用约定通过`call`和`ret`指令以及显式参数进行抽象。 与机器代码的另一个显着区别是LLVM IR不使用一组固定的命名寄存器，它使用一组以`％`字符命名的无限临时值。

除了作为一种语言实现之外，LLVM IR实际上以三种同构形式的定义：上面的文本格式，还有由优化本身检查和修改的内存中的数据结构，以及高效且密集的磁盘二进制“bitcode”格式。 LLVM项目还提供了将磁盘格式从文本转换为二进制的工具： `llvm-as`将文本`.ll`文件组装成包含bitcode goop的`.bc`文件， `llvm-dis`将`.bc`文件转换为`.ll`文件。

编译器的中间表示很有意思，因为它可以是编译器优化器的“完美世界”：与编译器的前端和后端不同，优化器不受特定源语言或特定目标机器的约束。  另一方面，它必须有很好地服务：它必须被设计成易于前端使用,生成针对目标硬件充分优化的代码。

#### 1.3.1 编写LLVM IR优化

为了对优化如何工作提供一些直观感受，下面通过一些例子。 有许多不同类型的编译器优化，因此很难提供能够解决任意问题的方法。 也就是说，大多数优化都遵循一个简单的三部分结构：

- 寻找要转变的模式。
- 验证匹配实例的转换是否安全/正确。
- 进行转换，更新代码。

最简单的优化是对算术标识的模式匹配，例如：对于任何整数`X` ， `X-X`为0， `X-0`为`X` ， `(X*2)-X`为`X` 第一个问题是LLVM IR中的这些问题。 一些例子是：

```
⋮    ⋮    ⋮
%example1 = sub i32 %a, %a
⋮    ⋮    ⋮
%example2 = sub i32 %b, 0
⋮    ⋮    ⋮
%tmp = mul i32 %c, 2
%example3 = sub i32 %tmp, %c
⋮    ⋮    ⋮
```

对于这些“洞察”转换，LLVM提供了一个指令简化接口，通过各种其他更高级别的转换用作实用程序。 这些特定的转换在`SimplifySubInst`函数中，如下所示：

```c
// X - 0 -> X
if (match(Op1, m_Zero()))
  return Op0;

// X - X -> 0
if (Op0 == Op1)
  return Constant::getNullValue(Op0->getType());

// (X*2) - X -> X
if (match(Op0, m_Mul(m_Specific(Op1), m_ConstantInt<2>())))
  return Op1;

…

return 0;  // Nothing matched, return null to indicate no transformation.
```

在此代码中，`Op0`和`Op1`绑定到整数减法指令的左右操作数（重要的是，这些标识不一定适用于IEEE浮点数！）。 LLVM是用C ++实现的，它的模式匹配功能并不为人所熟知（与Objective Caml等功能语言相比），但它提供了一个非常通用的模板系统，允许我们实现类似的东西。 `match`函数和`m_`函数允许我们对LLVM IR代码执行声明性模式匹配操作。 例如，如果乘法的左侧与`Op1`相同，则`m_Specific`谓词仅匹配。

总之，这三种情况都是模式匹配的，如果可以，函数返回替换，如果不可以替换，则返回空指针。 此函数的调用者（ `SimplifyInstruction` ）是一个调度程序，它对指令操作码进行切换，并调度到每操作码辅助函数。 它是从各种优化中调用的。 一个简单的驱动程序如下所示：

```c++
for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ++I)
  if (Value *V = SimplifyInstruction(I))
    I->replaceAllUsesWith(V);
```

这段代码简单地循环遍历块中的每条指令，检查它们是否有任何简化。 如果可以（因为`SimplifyInstruction`返回非null），它会使用`replaceAllUsesWith`方法使用更简单的形式更新代码中的任何内容。

### 1.4 LLVM实现三阶段设计

在基于LLVM的编译器中，前端负责解析，验证和诊断输入代码中的错误，然后将解析的代码转换为LLVM IR（通常但不总是通过构建AST然后将AST转换为LLVM IR）。 该IR可选地通过一系列改进代码的分析和优化过程提供，然后被发送到代码生成器以生成本机机器代码， 如图所示。 这是三阶段设计的一个非常简单的实现，但是这个简单的描述掩盖了LLVM架构从LLVM IR派生的一些功能和灵活性。

![LLVMCompiler1](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/LLVMCompiler1.png) 



#### 1.4.1 LLVM IR是完整的代码表示

特别是，LLVM IR既是明确指定的，也是优化器的*唯一*接口。 这个属性意味着为LLVM编写前端所需要知道的就是LLVM IR是什么，它是如何工作的，以及它所期望哪些不需要改变。 由于LLVM IR具有第一类的文本形式，因此构建时将LLVM IR作为文本输出的前端也是合理的，然后使用Unix管道通过您选择的优化器序列和代码生成器来发送它。

这可能是令人惊讶的，但这实际上是LLVM的一个非常新颖的特性，也是其在各种不同应用中取得成功的主要原因之一。 即使是广泛成功且相对精心设计的GCC编译器也没有这个属性：它的GIMPLE中级表示不是一个独立的表示。 举个简单的例子，当GCC代码生成器发出DWARF调试信息时，它会返回并遍历源级"树"形式。GIMPLE本身对代码中的操作使用“元组”表示，但（至少从GCC 4.5开始）仍将操作数表示为返回源级树形式的引用。

这意味着前端作者需要知道并生成GCC的树数据结构以及GIMPLE来编写GCC前端。 GCC后端有类似的问题，因此他们还需要了解RTL后端的工作原理。 最后，GCC没有办法转储“代表我代码的所有内容”，或者以文本形式读取和编写GIMPLE（以及构成代码表示的相关数据结构）的方法。 结果是，用GCC进行实验相对困难，因此它的前端相对较少。

#### 1.4.2  LLVM是一个库集合

在LLVM IR的设计之后，LLVM的下一个最重要的方面是把它设计为一组库，而不是像GCC这样的单独命令行编译器或像JVM或.NET虚拟机那样的不透明虚拟机。 LLVM是一种基础结构，是一组有用的编译器技术，可以解决特定问题（例如构建C编译器或特殊效果管道中的优化器）。 虽然它LLVM最强大的功能之一，但也是人们最不了解的设计点之一。

让我们看看优化器设计的一个例子：它读取LLVM IR，稍微处理它，然后发出LLVM IR，希望能更快地执行。 在LLVM中（与许多其他编译器一样），优化器被组织为不同优化传递的管道，每个优化在输入上传递运行并且可以执行某些优化操作。 传递的常见示例是内联器（将函数体替换为调用站点），表达式重新关联，循环不变代码运动等。根据优化级别，运行不同的传递：例如在`-O0`（无优化） Clang编译器不运行任何传递，在`-O3`它在其优化器中运行总共67次传递（从LLVM 2.8开始）。

每个LLVM传递都被编写为C ++类，它从`Pass`类派生（间接）。 大多数传递都是用单个`.cpp`文件编写的，而`Pass`类的子类是在匿名命名空间中定义的（这使得它对定义文件完全私有）。 为了使传递有用，文件外部的代码必须能够获取它，因此从文件中导出单个函数（创建传递）。 这是一个略微简化的例子，用于使事情具体化。

```c++
namespace {
  class Hello : public FunctionPass {
  public:
    // Print out the names of functions in the LLVM IR being optimized.
    virtual bool runOnFunction(Function &F) {
      cerr << "Hello: " << F.getName() << "\n";
      return false;
    }
  };
}

FunctionPass *createHelloPass() { return new Hello(); }
```

如上所述，LLVM优化器提供了许多不同的传递，每个传递都以类似的方式编写。 这些传递被编译成一个或多个`.o`文件，然后将这些文件构建到一系列静态文件（Unix系统上的`.a`文件）中。 这些库提供了各种各样的分析和转换功能，并且通道尽可能松散地耦合：如果它们依赖于其他分析来完成它们的工作，它们应该独立存在，或者在其他通道中明确声明它们的依赖关系。 当给出一系列要运行的传递时，LLVM PassManager使用显式依赖关系信息来满足这些依赖关系并优化传递的执行。

库和抽象功能很棒，但它们实际上并不能解决问题。 当有人想要构建一个可以从编译器技术中受益的新工具时，有趣的是，可能是用于图像处理语言的JIT编译器。 此JIT编译器的实现者在设计时考虑了一组约束：例如，图像处理语言可能对编译时延迟高度敏感，并且具有一些惯用语言属性，这些属性出于性能原因进行优化非常重要。

LLVM优化器的基于库的设计允许我们的实现者选择执行传递的顺序，以及哪些对图像处理域有意义：如果所有内容都被定义为单个大函数，则它不会感觉浪费时间内联。 如果指针很少，别名分析和内存优化就不值得烦恼了。 然而，尽管我们尽最大努力，但LLVM并没有神奇地解决所有优化问题！ 由于传递子系统是模块化的，并且PassManager本身对传递的内部不了解，因此实现者可以自由地实现他们自己的语言特定传递，以弥补LLVM优化器中的缺陷或明确的语言特定优化机会。 下图显示了我们假设的XYZ图像处理系统的一个简单示例：

![PassLinkage](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/PassLinkage.png)

​							使用LLVM的假设XYZ系统

一旦选择了一组优化（并且对代码生成器做出了类似的决定），图像处理编译器就被构建到可执行或动态库中。 由于对LLVM优化传递的唯一引用是每个`.o`文件中定义的简单`create`函数，并且由于优化器位于`.a`静态文件中，因此只有*实际使用*的优化传递链接到最终应用程序，而不是整个LLVM优化器。 在上面的示例中，由于存在对PassA和PassB的引用，它们将被链接。由于PassB使用PassD进行一些分析，因此PassD被链接。但是，因为PassC（以及许多其他优化）未被使用，它的代码没有链接到图像处理应用程序。

这就是基于库设计的LLVM的强大功能。 这种简单的设计方法允许LLVM提供大量功能，其中一些功能可能仅对特定受众有用，而不会损害只想做简单事情的库的客户端。 相比之下，传统的编译器优化器是作为紧密互连的大量代码构建的，这对于子集，推理和加速来说要困难得多。 使用LLVM，您可以了解各个优化器，而无需了解整个系统如何组合在一起。

这种基于库的设计也是为什么很多人误解LLVM的原因：LLVM库有很多功能，但它们实际上*并*没有自己*做*任何事情。 由库的客户端（例如，Clang C编译器）的设计者来决定如何最好地使用这些部件。 这种仔细的分层，分解和关注子集的能力也是LLVM优化器可广泛用于不同环境,不同应用的原因。 此外，仅仅因为LLVM提供JIT编译功能，并不意味着每个客户端都使用它。 

### 1.5 可重定向LLVM代码生成器的设计 

LLVM代码生成器负责将LLVM IR转换为目标特定的机器代码。 一方面，代码生成器的任务是为任何给定目标生成最佳机器代码。 理想情况下，每个代码生成器应该是针对特定目标硬件的完全独立实现，但另一方面，每个目标的代码生成器需要解决非常类似的问题。 例如，每个目标需要为寄存器分配值，尽管每个目标具有不同的寄存器文件，但应尽可能共享所使用的算法。

与优化器中的方法类似，LLVM的代码生成器将代码生成问题分解为单独的传递 - 指令选择，寄存器分配，调度，代码布局优化和汇编发射 - 并提供许多默认运行的内置传递。 然后，目标硬件作者有机会在默认传递中进行选择，覆盖默认值并根据需要实现完全自定义的特定于目标的传递。 例如，x86后端使用寄存器压力降低调度程序，因为它只有很少的寄存器，但PowerPC后端使用延迟优化调度程序，因为它有很多寄存器。 x86后端使用自定义传递来处理x87浮点堆栈，ARM后端使用自定义传递将常量池岛放置在需要的函数内。 这种灵活性允许目标作者生成高效的代码，而无需从头开始为其目标硬件编写整个代码生成器。

#### 1.5.1  LLVM目标描述文件

“混合和匹配”的方法允许目标硬件作者选择对其体系结构有意义的内容，并允许跨不同目标重用大量代码。 这带来了另一个挑战：每个共享组件都需要能够以通用方式推断目标特定属性。 例如，共享寄存器分配器需要知道每个目标硬件的寄存器文件以及指令与其寄存器操作数之间存在的约束。 LLVM的解决方案是为每个目标提供由tblgen工具处理的声明性特定语言（一组`.td`文件）的目标描述。 x86目标的（简化）构建过程[如图11.5](https://translate.googleusercontent.com/translate_c?act=url&depth=1&hl=zh-CN&ie=UTF8&prev=_t&rurl=translate.google.com.hk&sl=en&sp=nmt4&tl=zh-CN&u=http://www.aosabook.org/en/llvm.html&xid=17259,1500000,15700023,15700124,15700149,15700186,15700191,15700201&usg=ALkJrhinVvXb6fPVCPRe2wOKN2jF14NpYQ#fig.llvm.x86)所示。

![X86Target](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/X86Target.png)

 `.td`文件支持的不同子系统允许目标作者构建其目标的不同部分。 例如，x86后端定义了一个寄存器类，它包含所有名为`GR32`的32位寄存器（在`.td`文件中，目标特定定义都是大写），如下所示：

```
def GR32 : RegisterClass<[i32], 32,
  [EAX, ECX, EDX, ESI, EDI, EBX, EBP, ESP,
   R8D, R9D, R10D, R11D, R14D, R15D, R12D, R13D]> { … }
```

这个定义是说这个类中的寄存器可以保存32位整数值（“i32”），更喜欢32位对齐，具有指定的16个寄存器（在`.td`文件的其他地方定义）并有更多信息指定首选分配顺序和其他东西。 给定此定义，特定指令可以引用它，将其用作操作数。 例如，“完整32位寄存器”指令定义为：

```
let Constraints = "$src = $dst" in
def NOT32r : I<0xF7, MRM2r,
               (outs GR32:$dst), (ins GR32:$src),
               "not{l}\t$dst",
               [(set GR32:$dst, (not GR32:$src))]>;
```

这个定义说NOT32r是一个指令（它使用`I` tblgen类），指定编码信息（ `0xF7, MRM2r` ），指定它定义一个“输出”32位寄存器`$dst`并具有一个32位寄存器“输入”名为`$src` （上面定义的`GR32`寄存器类定义哪些寄存器对操作数有效），指定指令的汇编语法（使用`{}`语法处理AT＆T和Intel语法），指定指令的效果并提供它应该在最后一行匹配的模式。 第一行的“let”约束告诉寄存器分配器必须将输入和输出寄存器分配给同一物理寄存器。

这个定义是对指令的非常密集的描述，并且通用的LLVM代码可以使用从它派生的信息（通过`tblgen`工具）做很多`tblgen` 。 这个定义足以使指令选择通过编译器的输入IR代码上的模式匹配来形成该指令。 它还告诉寄存器分配器如何处理它，足以对指令进行编码和解码以加工代码字节，并且足以以文本形式解析和打印指令。 这些功能允许x86目标支持生成独立的x86汇编程序（它是“gas”GNU汇编程序的直接替代品）和目标描述中的反汇编程序以及处理JIT指令的编码。

除了提供有用的功能之外，具有由相同“真实”生成的多条信息也有其他原因。 这种方法使得汇编器和反汇编器在汇编语法或二进制编码中彼此不一致时几乎是不可行的。 它还使目标描述易于测试：指令编码可以进行单元测试，而不必涉及整个代码生成器。

虽然我们的目标是以一个很好的声明形式将尽可能多的目标信息放到`.td`文件中，但我们仍然没有解决所有问题。 相反，我们要求目标作者为各种支持例程编写一些C ++代码，并实现他们可能需要的任何目标特定传递（如`X86FloatingPoint.cpp` ，它处理x87浮点堆栈）。随着LLVM继续增长新目标，增加可以在`.td`文件中表达的目标数量变得越来越重要，并且我们继续增加`.td`文件的表达力来处理这个问题。一个很大的好处是随着时间的推移，它可以越来越容易地在LLVM中编写目标。

### 1.6 模块化设计提供的有用功能

除了优雅的设计外，模块化还为LLVM库的客户提供了一些有趣的功能。这些功能源于LLVM提供，但让客户决定如何使用它的大多数*策略*。

#### 1.6.1 选择每个阶段运行的时间和地点

如前所述，LLVM IR可以有效地（反）序列化为/LLVM bitcode的二进制格式。由于LLVM IR是自包含的，并且序列化是一个无损过程，我们可以进行部分编译，将进度保存到磁盘，然后在将来的某个时间点继续工作。此特系能提供了许多有趣的功能，包括对链接时和安装时优化的支持，这两种功能都会从“编译时”延迟代码生成。

链接时优化（LTO）解决了编译器传统上一次只看到一个转换单元（例如，`.c`具有其所有头的文件）的问题，因此不能跨文件边界进行优化（如内联）。Clang等LLVM编译器使用`-flto`或`-O4`命令行选项支持此功能。此选项指示编译器向`.o`文件发出LLVM bitcode，而不是写出本机对象文件，并将代码生成延迟到链接时间，如图所示。

![LTO](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/LTO.png)

细节因您所使用的操作系统而异，但重要的是链接器检测到它具有LLVM bitcode `.o`文件而不是本机对象文件。当它看到这一点时，它会将所有bitcode文件读入内存，将它们链接在一起，然后在聚合上运行LLVM优化器。由于优化器现在可以看到代码的更大部分，它可以内联，传播常量，执行更积极的死代码消除，以及更多跨文件边界。虽然许多现代编译器支持LTO，但大多数（例如，GCC，Open64，英特尔编译器等）都是通过昂贵且缓慢的序列化过程来实现的。在LLVM中，LTO自然地脱离了系统的设计，并且适用于不同的源语言（与许多其他编译器不同），因为IR是真正的中间源语言。

安装时优化是延迟代码生成的想法，甚至比链接时间晚，一直到安装时间，下图所示。安装时间是一个非常有趣的时间（如果软件在一个盒子中发货，下载，上传到移动设备等），因为这是当你找到你所针对的设备的细节时。例如，在x86系列中，存在各种各样的芯片和特性。通过延迟指令选择，调度和代码生成的其他方面，您可以为应用程序最终运行的特定硬件选择最佳答案。

![InstallTime](/home/cyoung/CLionProjects/implement_llvm/doc/image/Intro to LLVM/InstallTime.png)

#### 1.6.2 单元测试优化器

编译器非常复杂，质量很重要，因此测试至关重要。例如，在修复导致优化器崩溃的错误之后，应添加回归测试以确保它不会再次发生。测试这种方法的传统方法是编写一个`.c`通过编译器运行的文件（例如），并使用一个测试工具来验证编译器是否崩溃。例如，这是GCC测试套件使用的方法。

这种方法的问题在于编译器由许多不同的子系统组成，甚至包括优化器中的许多不同的传递，所有这些传递都有可能在到达之前有问题的代码时改变输入代码的表达意思。如果前端或早期优化器发生了某些变化，测试用例很容易无法测试它应该测试的内容。

通过使用LLVM IR的文本形式和模块化优化器，LLVM测试套件具有高度集中的回归测试，可以从磁盘加载LLVM IR，通过一次优化传递运行它，并验证预期的行为。除了崩溃之外，更复杂的行为测试想要验证实际执行了优化。这是一个简单的测试用例，它检查常量传播过程是否与添加指令一起使用：

```
; RUN: opt < %s -constprop -S | FileCheck %s
define i32 @test() {
  %A = add i32 4, 5
  ret i32 %A
  ; CHECK: @test()
  ; CHECK: ret i32 9
}
```

该`RUN`行指定要执行的命令：在这种情况下，`opt`和`FileCheck`命令行工具。该`opt`程序是LLVM传递管理器的简单包装器，它连接所有标准传递（并且可以动态加载包含其他传递的插件）并将它们公开到命令行。该`FileCheck`工具验证其标准输入是否与一系列`CHECK`指令匹配。在这种情况下，这个简单的测试是验证`constprop`传球将`add`4和5 折叠成9。

虽然这看起来像是一个非常简单的例子，但通过编写.c文件来测试很难：前端经常在解析时进行常量折叠，因此编写下游到常量的代码是非常困难和脆弱的折叠优化通过。因为我们可以将LLVM IR作为文本加载并通过我们感兴趣的特定优化传递发送它，然后将结果转储为另一个文本文件，对于回归和功能测试来说，确切地测试我们想要的内容真的很简单。

#### 1.6.3 使用BugPoint自动减少测试用例

当在LLVM库的编译器或其他客户端中发现错误时，修复它的第一步是获得一个再现问题的测试用例。一旦有了测试用例，最好将其最小化为再现问题的最小示例，并将其缩小到发生问题的LLVM部分，例如故障时的优化传递。虽然您最终会学习如何执行此操作，但是对于编译器生成错误代码但不会崩溃的情况，此过程非常繁琐，手动且特别痛苦。

LLVM BugPoint工具使用LLVM 的IR序列化和模块化设计来自动执行此过程。例如，给定一个输入`.ll`或`.bc`文件以及导致优化器崩溃的优化传递列表，BugPoint会将输入减少到一个小测试用例并确定哪个优化器出错。然后它输出简化的测试用例和`opt`用于重现失败的命令。它通过使用类似于“delta debugging”的技术来减少输入和优化器传递列表。因为它知道LLVM IR的结构，所以与标准的“delta”命令行工具不同，BugPoint不会浪费时间生成无效的IR来输入优化器。

在更复杂的错误编译情况下，您可以指定输入，代码生成器信息，传递给可执行文件的命令行以及参考输出。 BugPoint将首先确定问题是由优化器还是代码生成器引起的，然后将测试用例重复分为两部分：一部分被发送到“已知良好”组件，另一部分被发送到“已知错误” “ 零件。通过迭代地将越来越多的代码移出已发送到已知错误代码生成器的分区，它减少了测试用例。

BugPoint是一个非常简单的工具，在LLVM的整个生命周期中节省了无数小时的测试用例。没有其他开源编译器具有类似功能强大的工具，因为它依赖于明确定义的中间表示。也就是说，BugPoint并不完美，并且会从重写中获益。它可以追溯到2002年，并且通常只有当某人有一个非常棘手的错误来追踪现有工具处理得不好时才会改进。它随着时间的推移而增长，在没有一致设计或所有者的情况下积累新功能（例如JIT调试）。

### 1.7 回顾和未来的方向

LLVM的模块化最初并非旨在直接实现此处描述的任何目标。这是一种自卫机制：很明显，我们不会在第一次尝试时把一切都弄好。例如，存在模块化传递管道，以便更容易隔离传递，以便在被更好的实现替换后可以丢弃它们。

LLVM保持灵活的另一个主要方面（以及与库使用者有争议的话题）是我们愿意重新考虑先前的决策并对API进行广泛的更改而不必担心向后兼容性。例如，对LLVM IR本身的侵入性更改需要更新所有优化过程并导致对C ++ API的大量改变。我们已经多次这样做了，尽管它会给客户带来痛苦，但保持快速前进是正确的。为了使外部客户端的生活更轻松（并支持其他语言的绑定），我们为许多流行的API（旨在非常稳定）提供C包装器，新版本的LLVM旨在继续读取旧的`.ll`和`.bc`文件。

展望未来，我们希望继续使LLVM更加模块化，更易于子集化。例如，代码生成器仍然过于单一：目前无法根据功能对LLVM进行子集化。例如，如果您想使用JIT，但不需要内联汇编，异常处理或调试信息生成，则应该可以构建代码生成器而无需链接以支持这些功能。我们还不断提高优化器和代码生成器生成的代码质量，添加IR功能以更好地支持新语言和目标构造，并为在LLVM中执行高级语言特定优化添加更好的支持。

LLVM项目以多种方式不断发展和完善。看到LLVM在其他项目中使用的不同方式的数量以及它如何在设计师从未想过的令人惊讶的新环境中不断出现，真是令人兴奋。新的LLDB调试器就是一个很好的例子：它使用Clang的C / C ++ / Objective-C解析器来解析表达式，使用LLVM JIT将它们转换为目标代码，使用LLVM反汇编程序，并使用LLVM目标来处理调用约定等等。能够重用这些现有代码允许开发调试器的人专注于编写调试器逻辑，而不是重新实现另一个（边缘正确的）C ++解析器。

尽管迄今为止取得了成功，但仍有许多工作要做，以及随着年龄的增长LLVM将变得不那么灵活和更加钙化的风险始终存在。虽然这个问题没有神奇的答案，但我希望继续接触新的问题领域，重新评估以前的决策，重新设计和丢弃代码的意愿将有所帮助。毕竟，目标不是完美，而是随着时间的推移不断变得更好。